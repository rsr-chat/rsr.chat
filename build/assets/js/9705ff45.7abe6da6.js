"use strict";(globalThis.webpackChunkdocs=globalThis.webpackChunkdocs||[]).push([[4251],{3107(e,n,i){i.r(n),i.d(n,{assets:()=>c,contentTitle:()=>a,default:()=>o,frontMatter:()=>d,metadata:()=>s,toc:()=>l});const s=JSON.parse('{"id":"proto/extensions/channel-pins","title":"rsr.chat/channel-pins","description":"This specification is still a draft and is subject to change at any time.","source":"@site/docs/proto/1500_extensions/channel-pins.md","sourceDirName":"proto/1500_extensions","slug":"/proto/extensions/channel-pins","permalink":"/docs/proto/extensions/channel-pins","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{"title":"rsr.chat/channel-pins"},"sidebar":"protoSidebar","previous":{"title":"rsr.chat/channel-meta","permalink":"/docs/proto/extensions/channel-meta"},"next":{"title":"rsr.chat/did-sasl","permalink":"/docs/proto/extensions/did-sasl"}}');var t=i(4848),r=i(8453);const d={title:"rsr.chat/channel-pins"},a="rsr.chat/channel-pins",c={},l=[{value:"Motivation",id:"motivation",level:2},{value:"Capability",id:"capability",level:2},{value:"ISUPPORT Tokens",id:"isupport-tokens",level:2},{value:"Dependencies",id:"dependencies",level:2},{value:"Terminology",id:"terminology",level:2},{value:"Channel Identity Constraint",id:"channel-identity-constraint",level:2},{value:"Reserved Metadata Keys",id:"reserved-metadata-keys",level:2},{value:"<code>pin-count</code>",id:"pin-count",level:3},{value:"<code>pin-messages</code>",id:"pin-messages",level:3},{value:"Commands",id:"commands",level:2},{value:"PIN ADD",id:"pin-add",level:3},{value:"PIN REMOVE",id:"pin-remove",level:3},{value:"PIN LIST",id:"pin-list",level:3},{value:"PIN GET",id:"pin-get",level:3},{value:"Server Numerics",id:"server-numerics",level:2},{value:"Pin Entry Persistence",id:"pin-entry-persistence",level:2},{value:"Message Expiry and Pin Integrity",id:"message-expiry-and-pin-integrity",level:2},{value:"Default Permissions",id:"default-permissions",level:2},{value:"Guild Integration",id:"guild-integration",level:2},{value:"RBAC Integration",id:"rbac-integration",level:2},{value:"Advanced Moderation Integration",id:"advanced-moderation-integration",level:2},{value:"Interaction with Non-Negotiating Clients",id:"interaction-with-non-negotiating-clients",level:2}];function h(e){const n={admonition:"admonition",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,r.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.admonition,{type:"warning",children:(0,t.jsxs)(n.p,{children:["This specification is still a ",(0,t.jsx)(n.strong,{children:"draft"})," and is subject to change at any time."]})}),"\n",(0,t.jsx)(n.header,{children:(0,t.jsx)(n.h1,{id:"rsrchatchannel-pins",children:"rsr.chat/channel-pins"})}),"\n",(0,t.jsxs)(n.p,{children:["This extension allows messages to be pinned within the channel they were originally sent\nin. Pinned messages are surfaced via a structured list and represented as a reserved\nchannel metadata key. Each pin is identified by the message ID assigned by\n",(0,t.jsx)(n.code,{children:"rsr.chat/message-link"}),". A message may only be pinned to the channel it was originally\nsent in; cross-channel pinning is explicitly prohibited."]}),"\n",(0,t.jsx)(n.h2,{id:"motivation",children:"Motivation"}),"\n",(0,t.jsx)(n.p,{children:"Pinned messages are a widely used affordance for surfacing important, persistent\ninformation in a channel \u2014 rules, announcements, links, or decisions without relying\non the topic field or repeating the content manually. This extension provides a\nserver-authoritative pin list that is portable, auditable, and integrated with the\nexisting message identity and metadata infrastructure of this suite."}),"\n",(0,t.jsx)(n.h2,{id:"capability",children:"Capability"}),"\n",(0,t.jsxs)(n.p,{children:["This extension is advertised as the ",(0,t.jsx)(n.code,{children:"rsr.chat/channel-pins"})," capability during CAP\nnegotiation:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"CAP * LS :rsr.chat/channel-pins\n"})}),"\n",(0,t.jsx)(n.p,{children:"No capability value is used. Limits are communicated via ISUPPORT (see below)."}),"\n",(0,t.jsx)(n.h2,{id:"isupport-tokens",children:"ISUPPORT Tokens"}),"\n",(0,t.jsx)(n.p,{children:"Servers MUST advertise the following tokens in RPL_ISUPPORT (005) when this capability\nis active:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"PINMAX=<n>"})," \u2014 the maximum number of pinned messages permitted per channel. A value\nof ",(0,t.jsx)(n.code,{children:"0"})," indicates no server-imposed limit. The recommended default is ",(0,t.jsx)(n.code,{children:"50"}),"."]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"Example:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:":server 005 nick PINMAX=50 :are supported by this server\n"})}),"\n",(0,t.jsx)(n.p,{children:"If this value changes after a configuration reload, a fresh RPL_ISUPPORT MUST be sent\nto all connected clients."}),"\n",(0,t.jsx)(n.h2,{id:"dependencies",children:"Dependencies"}),"\n",(0,t.jsx)(n.p,{children:"This extension has two hard dependencies:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"rsr.chat/message-link"})," \u2014 required to identify messages by their server-assigned\n",(0,t.jsx)(n.code,{children:"rsr.chat/msgid"})," tag. Servers MUST NOT advertise ",(0,t.jsx)(n.code,{children:"rsr.chat/channel-pins"})," if\n",(0,t.jsx)(n.code,{children:"rsr.chat/message-link"})," is not active."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"rsr.chat/channel-metadata"})," \u2014 required to store the pin list as a reserved metadata\nkey and to surface pin count. Servers MUST NOT advertise ",(0,t.jsx)(n.code,{children:"rsr.chat/channel-pins"})," if\n",(0,t.jsx)(n.code,{children:"rsr.chat/channel-metadata"})," is not active."]}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"terminology",children:"Terminology"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Pin"}),": an association between a channel and a message ID, asserting that the\nreferenced message was sent in that channel and has been designated as notable."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Pin entry"}),": a record consisting of a message ID, the channel it was pinned in, the\naccount name of the pinner, and the timestamp at which the pin was created."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Pin list"}),": the ordered sequence of pin entries for a channel, ordered from most\nrecently pinned to least recently pinned."]}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"channel-identity-constraint",children:"Channel Identity Constraint"}),"\n",(0,t.jsx)(n.p,{children:"A message MUST only be pinned to the channel in which it was originally sent. The server\nMUST verify this by consulting its message store. If the message ID does not correspond\nto a message in the target channel, the server MUST reject the pin attempt as if the message\ndid not exist."}),"\n",(0,t.jsx)(n.h2,{id:"reserved-metadata-keys",children:"Reserved Metadata Keys"}),"\n",(0,t.jsxs)(n.p,{children:["When both ",(0,t.jsx)(n.code,{children:"rsr.chat/channel-metadata"})," and ",(0,t.jsx)(n.code,{children:"rsr.chat/channel-pins"})," are active, the\nfollowing keys exist implicitly on every channel and MUST NOT be deleted."]}),"\n",(0,t.jsx)(n.h3,{id:"pin-count",children:(0,t.jsx)(n.code,{children:"pin-count"})}),"\n",(0,t.jsxs)(n.p,{children:["Type: ",(0,t.jsx)(n.code,{children:"uint"}),". The current number of pinned messages in this channel. Updated by the\nserver on each PIN ADD or PIN REMOVE. Read-only; attempts to set via CHANMETA SET MUST\nresult in ",(0,t.jsx)(n.code,{children:"ERR_CHANMETAREADONLY"}),"."]}),"\n",(0,t.jsx)(n.h3,{id:"pin-messages",children:(0,t.jsx)(n.code,{children:"pin-messages"})}),"\n",(0,t.jsxs)(n.p,{children:["Type: ",(0,t.jsx)(n.code,{children:"TEXT"}),". A JSON-encoded list of message IDs that are pinned, in pin order.\nRead-only; attempts to set via CHANMETA SET MUST result in ",(0,t.jsx)(n.code,{children:"ERR_CHANMETAREADONLY"}),"."]}),"\n",(0,t.jsx)(n.p,{children:"Both keys appear in CHANMETA LIST responses as normal metadata entries."}),"\n",(0,t.jsx)(n.h2,{id:"commands",children:"Commands"}),"\n",(0,t.jsx)(n.h3,{id:"pin-add",children:"PIN ADD"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"PIN <channel> ADD <msgid>\n"})}),"\n",(0,t.jsxs)(n.p,{children:["Pins the message identified by ",(0,t.jsx)(n.code,{children:"<msgid>"})," in ",(0,t.jsx)(n.code,{children:"<channel>"}),". The server MUST verify:"]}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsx)(n.li,{children:"The message ID is known to the server's message store."}),"\n",(0,t.jsxs)(n.li,{children:["The message was actually sent in ",(0,t.jsx)(n.code,{children:"<channel>"}),"."]}),"\n",(0,t.jsx)(n.li,{children:"The message is not already pinned in this channel."}),"\n",(0,t.jsxs)(n.li,{children:["The channel has not reached the ",(0,t.jsx)(n.code,{children:"PINMAX"})," limit."]}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:["If all conditions are satisfied, the server adds the pin entry to the top of the pin list\nand broadcasts a ",(0,t.jsx)(n.code,{children:"PIN ADD"})," notification to all active channel members that have\nnegotiated this capability:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:":pinner!user@host PIN #channel ADD <msgid> <pin-timestamp>\n"})}),"\n",(0,t.jsxs)(n.p,{children:["Where ",(0,t.jsx)(n.code,{children:"<pin-timestamp>"})," is an ISO 8601 UTC timestamp indicating when the pin was created."]}),"\n",(0,t.jsxs)(n.p,{children:["The server MUST also update the ",(0,t.jsx)(n.code,{children:"pin-count"})," and ",(0,t.jsx)(n.code,{children:"pin-messages"})," reserved metadata keys\natomically with the pin creation, and MUST broadcast the corresponding CHANMETA SET\nnotifications to members that have negotiated ",(0,t.jsx)(n.code,{children:"rsr.chat/channel-metadata"}),"."]}),"\n",(0,t.jsx)(n.h3,{id:"pin-remove",children:"PIN REMOVE"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"PIN <channel> REMOVE <msgid>\n"})}),"\n",(0,t.jsxs)(n.p,{children:["Removes the pin for the message identified by ",(0,t.jsx)(n.code,{children:"<msgid>"})," from ",(0,t.jsx)(n.code,{children:"<channel>"}),". If the message\nis not currently pinned the server MUST reply with ERR_PINNOTFOUND."]}),"\n",(0,t.jsxs)(n.p,{children:["On success the server MUST broadcast a ",(0,t.jsx)(n.code,{children:"PIN REMOVE"})," notification to all active channel\nmembers that have negotiated this capability:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:":remover!user@host PIN #channel REMOVE <msgid>\n"})}),"\n",(0,t.jsxs)(n.p,{children:["The server MUST update ",(0,t.jsx)(n.code,{children:"pin-count"})," and ",(0,t.jsx)(n.code,{children:"pin-messages"})," atomically."]}),"\n",(0,t.jsx)(n.h3,{id:"pin-list",children:"PIN LIST"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"PIN <channel> LIST\n"})}),"\n",(0,t.jsxs)(n.p,{children:["Requests the full pin list for the channel. If IRCv3 ",(0,t.jsx)(n.code,{children:"batch"})," is negotiated the response\nMUST be wrapped in a ",(0,t.jsx)(n.code,{children:"rsr.chat/pinlist"})," batch. The server responds with zero or more\nRPL_PINENTRY numerics followed by RPL_PINEND."]}),"\n",(0,t.jsx)(n.h3,{id:"pin-get",children:"PIN GET"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"PIN <channel> GET <msgid>\n"})}),"\n",(0,t.jsxs)(n.p,{children:["Requests the pin entry for a single message ID. The server replies with a single\nRPL_PINENTRY followed by ",(0,t.jsx)(n.code,{children:"RPL_PINEND"}),", or ",(0,t.jsx)(n.code,{children:"ERR_PINNOTFOUND"})," if the message is not pinned."]}),"\n",(0,t.jsx)(n.h2,{id:"server-numerics",children:"Server Numerics"}),"\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"Symbolic name"}),(0,t.jsx)(n.th,{children:"Description"})]})}),(0,t.jsxs)(n.tbody,{children:[(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"RPL_PINENTRY"})}),(0,t.jsx)(n.td,{children:"A single pin list entry"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"RPL_PINEND"})}),(0,t.jsx)(n.td,{children:"Marks the end of a PIN LIST or PIN GET response"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"ERR_PINNOTFOUND"})}),(0,t.jsx)(n.td,{children:"The specified message ID is not pinned in this channel"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"ERR_PINALREADYPINNED"})}),(0,t.jsx)(n.td,{children:"The specified message ID is already pinned in this channel"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"ERR_PINWRONGCHANNEL"})}),(0,t.jsx)(n.td,{children:"The message was not sent in the specified channel"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"ERR_PINUNKNOWNMSG"})}),(0,t.jsx)(n.td,{children:"The message ID is not known to the server's message store"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"ERR_PINFULL"})}),(0,t.jsx)(n.td,{children:"The channel has reached the PINMAX limit"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"ERR_PINNOPERM"})}),(0,t.jsx)(n.td,{children:"The client lacks permission to perform this pin operation"})]})]})]}),"\n",(0,t.jsx)(n.p,{children:"RPL_PINENTRY has the following format:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:":server RPL_PINENTRY <nick> <channel> <msgid> <pinner-account> <pin-timestamp> * :<body-preview>\n:server RPL_PINENTRY * :<body-preview-cont>\n:server RPL_PINENTRY   :<original-msg-tags-if-applicable>\n"})}),"\n",(0,t.jsx)(n.p,{children:"Where:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"msgid"})," is the pinned message ID."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"pinner-account"})," is the account name of the user who created the pin."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"pin-timestamp"})," is an ISO 8601 UTC timestamp of when the pin was created."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"body"})," is up to  bytes of the pinned message body, UTF-8, newlines replaced\nwith U+2424, truncated with a trailing ",(0,t.jsx)(n.code,{children:"\u2026"})," if necessary. This preview is generated at\npin creation time and stored with the pin entry; it is NOT re-fetched from message\nhistory on each LIST. If the referenced message has since expired from the message\nstore, the preview MUST still be returned as stored at pin time."]}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:"RPL_PINEND"})," has the following format:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:":server `RPL_PINEND` <nick> <channel> :End of pin list\n"})}),"\n",(0,t.jsx)(n.h2,{id:"pin-entry-persistence",children:"Pin Entry Persistence"}),"\n",(0,t.jsxs)(n.p,{children:["Pin entries are persistent records and MUST survive server restarts if the server\nsupports persistent storage. The body preview embedded in each ",(0,t.jsx)(n.code,{children:"RPL_PINENTRY"})," is captured\nat pin creation time precisely because the referenced message may eventually expire from\nthe message history store. The pin entry itself is not subject to message retention\nlimits."]}),"\n",(0,t.jsxs)(n.p,{children:["If a pinned message's ID becomes unresolvable in the message store (due to expiry), the\npin entry remains. The body preview is the authoritative display text. Clients SHOULD\nindicate to the user when a pinned message's full history context is no longer available,\nwhich they can determine by attempting ",(0,t.jsx)(n.code,{children:"CHATHISTORY"})," around the pin timestamp and finding\nno matching message."]}),"\n",(0,t.jsx)(n.h2,{id:"message-expiry-and-pin-integrity",children:"Message Expiry and Pin Integrity"}),"\n",(0,t.jsx)(n.p,{children:"Servers MUST NOT automatically remove pin entries when the underlying message expires\nfrom the history store. Pins outlive their source messages. If an operator or server\nprocess forcibly deletes a message (e.g. via a moderation action), the server SHOULD also\nremove the corresponding pin entry and broadcast a PIN REMOVE notification as if an\noperator had issued the command."}),"\n",(0,t.jsx)(n.h2,{id:"default-permissions",children:"Default Permissions"}),"\n",(0,t.jsxs)(n.p,{children:["Unless overridden by ",(0,t.jsx)(n.code,{children:"rsr.chat/rbac"}),", the following default permission rules apply:"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Any channel member MAY call PIN LIST and PIN GET."}),"\n",(0,t.jsxs)(n.li,{children:["Channel operators (mode ",(0,t.jsx)(n.code,{children:"+o"}),") and above MAY call PIN ADD and PIN REMOVE."]}),"\n",(0,t.jsx)(n.li,{children:"Setting and removing pins follows the same operator threshold as other channel\nmanagement operations."}),"\n",(0,t.jsx)(n.li,{children:"Server operators MAY call PIN ADD and PIN REMOVE on any channel."}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"A pinner MAY remove their own pin regardless of their current role, provided they were\nthe original pinner. Servers MUST track the pinner account per entry to support this."}),"\n",(0,t.jsx)(n.h2,{id:"guild-integration",children:"Guild Integration"}),"\n",(0,t.jsxs)(n.p,{children:["When ",(0,t.jsx)(n.code,{children:"rsr.chat/guild"})," is negotiated, guild operators MAY add and remove pins in any\nchannel within the guild without holding a channel-level operator role. Guild-level pin\noperations are broadcast and recorded identically to channel-level operations."]}),"\n",(0,t.jsx)(n.p,{children:"Guild operators MAY NOT pin messages from one guild channel into another; the channel\nidentity constraint (see Channel Identity Constraint) applies without exception regardless\nof guild role."}),"\n",(0,t.jsx)(n.h2,{id:"rbac-integration",children:"RBAC Integration"}),"\n",(0,t.jsxs)(n.p,{children:["When ",(0,t.jsx)(n.code,{children:"rsr.chat/rbac"})," is negotiated, the following permission identifiers are defined by\nthis extension:"]}),"\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"Permission identifier"}),(0,t.jsx)(n.th,{children:"Description"})]})}),(0,t.jsxs)(n.tbody,{children:[(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"pins.list"})}),(0,t.jsx)(n.td,{children:"View the pin list and individual pin entries"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"pins.add"})}),(0,t.jsx)(n.td,{children:"Add a new pin to the channel"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"pins.remove"})}),(0,t.jsx)(n.td,{children:"Remove any existing pin from the channel"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"pins.remove.own"})}),(0,t.jsx)(n.td,{children:"Remove a pin the requesting user originally created"})]})]})]}),"\n",(0,t.jsxs)(n.p,{children:["RBAC rules for these permissions MAY be scoped to a channel category or guild prefix\nusing the scope syntax defined by ",(0,t.jsx)(n.code,{children:"rsr.chat/channel-categories"}),"."]}),"\n",(0,t.jsx)(n.p,{children:"Example (illustrative; normative RBAC syntax defined in rsr.chat/rbac):"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"RBACSET #engineering/ ROLE op PERMISSION pins.add\nRBACSET #engineering/ ROLE op PERMISSION pins.remove\nRBACSET #acmecorp/ ROLE admin PERMISSION pins.add\n"})}),"\n",(0,t.jsx)(n.h2,{id:"advanced-moderation-integration",children:"Advanced Moderation Integration"}),"\n",(0,t.jsxs)(n.p,{children:["When ",(0,t.jsx)(n.code,{children:"rsr.chat/advanced-moderation"})," is negotiated, the following predicates are defined\nfor use in moderation rule conditions (normative syntax defined by that specification):"]}),"\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"Predicate"}),(0,t.jsx)(n.th,{children:"Matches when"})]})}),(0,t.jsxs)(n.tbody,{children:[(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"pins:is-pinned"})}),(0,t.jsx)(n.td,{children:"The referenced message is currently pinned"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"pins:pin-count>=<n>"})}),(0,t.jsx)(n.td,{children:"The channel has at least n pinned messages"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"pins:pin-count<=<n>"})}),(0,t.jsx)(n.td,{children:"The channel has at most n pinned messages"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"pins:pinner=<account>"})}),(0,t.jsx)(n.td,{children:"The pin was created by the specified account"})]})]})]}),"\n",(0,t.jsx)(n.p,{children:"These predicates may be used to gate actions on whether a channel is heavily pinned,\nto restrict moderation operations on pinned messages, or to trigger alerts when the pin\nlist reaches a threshold."}),"\n",(0,t.jsx)(n.h2,{id:"interaction-with-non-negotiating-clients",children:"Interaction with Non-Negotiating Clients"}),"\n",(0,t.jsxs)(n.p,{children:["Clients that have not negotiated ",(0,t.jsx)(n.code,{children:"rsr.chat/channel-pins"})," receive no PIN notifications.\nPIN commands sent by non-negotiating clients MUST be rejected with ",(0,t.jsx)(n.code,{children:"ERR_UNKNOWNCOMMAND"}),"."]}),"\n",(0,t.jsxs)(n.p,{children:["Non-negotiating clients may observe pin activity indirectly via the ",(0,t.jsx)(n.code,{children:"pin-count"})," and\n",(0,t.jsx)(n.code,{children:"pin-latest-msgid"})," reserved metadata keys if they have negotiated\n",(0,t.jsx)(n.code,{children:"rsr.chat/channel-metadata"}),", but receive no structural pin data."]})]})}function o(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(h,{...e})}):h(e)}},8453(e,n,i){i.d(n,{R:()=>d,x:()=>a});var s=i(6540);const t={},r=s.createContext(t);function d(e){const n=s.useContext(r);return s.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:d(e.components),s.createElement(r.Provider,{value:n},e.children)}}}]);