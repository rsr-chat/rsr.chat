"use strict";(globalThis.webpackChunkdocs=globalThis.webpackChunkdocs||[]).push([[7949],{6736(e,n,i){i.r(n),i.d(n,{assets:()=>o,contentTitle:()=>c,default:()=>h,frontMatter:()=>a,metadata:()=>r,toc:()=>d});const r=JSON.parse('{"id":"proto/extensions/channel-membership","title":"rsr.chat/channel-membership","description":"This specification is still a draft and is subject to change at any time.","source":"@site/docs/proto/1500_extensions/channel-membership.md","sourceDirName":"proto/1500_extensions","slug":"/proto/extensions/channel-membership","permalink":"/docs/proto/extensions/channel-membership","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{"title":"rsr.chat/channel-membership"},"sidebar":"protoSidebar","previous":{"title":"rsr.chat/channel-categories","permalink":"/docs/proto/extensions/channel-categories"},"next":{"title":"rsr.chat/channel-meta","permalink":"/docs/proto/extensions/channel-meta"}}');var s=i(4848),t=i(8453);const a={title:"rsr.chat/channel-membership"},c="rsr.chat/channel-membership",o={},d=[{value:"Motivation",id:"motivation",level:2},{value:"Capability",id:"capability",level:2},{value:"ISUPPORT Tokens",id:"isupport-tokens",level:2},{value:"Terminology",id:"terminology",level:2},{value:"Account Requirement",id:"account-requirement",level:2},{value:"Roles",id:"roles",level:2},{value:"Commands",id:"commands",level:2},{value:"CHMEMBER ADD",id:"chmember-add",level:3},{value:"CHMEMBER REMOVE",id:"chmember-remove",level:3},{value:"CHMEMBER SETROLE",id:"chmember-setrole",level:3},{value:"CHMEMBER LIST",id:"chmember-list",level:3},{value:"CHMEMBER INVITE",id:"chmember-invite",level:3},{value:"Server Numerics",id:"server-numerics",level:2},{value:"Interaction with Standard JOIN and PART",id:"interaction-with-standard-join-and-part",level:2},{value:"JOIN by a persistent member",id:"join-by-a-persistent-member",level:3},{value:"PART or QUIT by a persistent member",id:"part-or-quit-by-a-persistent-member",level:3},{value:"KICK of a persistent member",id:"kick-of-a-persistent-member",level:3},{value:"Channel destruction",id:"channel-destruction",level:3},{value:"NAMES and WHO Integration",id:"names-and-who-integration",level:2},{value:"IRCv3 Integration",id:"ircv3-integration",level:2},{value:"account-tag",id:"account-tag",level:3},{value:"away-notify",id:"away-notify",level:3},{value:"batch",id:"batch",level:3},{value:"chathistory",id:"chathistory",level:3},{value:"extended-join",id:"extended-join",level:3},{value:"invite-notify",id:"invite-notify",level:3},{value:"monitor",id:"monitor",level:3},{value:"Reserved Metadata Keys",id:"reserved-metadata-keys",level:2},{value:"<code>membership-count</code>",id:"membership-count",level:3},{value:"<code>membership-open</code>",id:"membership-open",level:3},{value:"Guild Integration",id:"guild-integration",level:2},{value:"Category Integration",id:"category-integration",level:2},{value:"RBAC Integration",id:"rbac-integration",level:2},{value:"Advanced Moderation Integration",id:"advanced-moderation-integration",level:2},{value:"Interaction with Non-Negotiating Clients",id:"interaction-with-non-negotiating-clients",level:2},{value:"Examples",id:"examples",level:2},{value:"Adding a persistent member",id:"adding-a-persistent-member",level:3},{value:"Persistent member joins and receives automatic mode",id:"persistent-member-joins-and-receives-automatic-mode",level:3},{value:"CHMEMBER LIST with batch",id:"chmember-list-with-batch",level:3},{value:"Persistent member parts; membership retained",id:"persistent-member-parts-membership-retained",level:3},{value:"Kick without membership removal",id:"kick-without-membership-removal",level:3},{value:"Kick with membership removal",id:"kick-with-membership-removal",level:3},{value:"Role change while member is active",id:"role-change-while-member-is-active",level:3},{value:"Offline member requesting history via chathistory",id:"offline-member-requesting-history-via-chathistory",level:3},{value:"Insufficient role error",id:"insufficient-role-error",level:3},{value:"Category-scoped ADD",id:"category-scoped-add",level:3}];function l(e){const n={admonition:"admonition",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,t.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.admonition,{type:"warning",children:(0,s.jsxs)(n.p,{children:["This specification is still a ",(0,s.jsx)(n.strong,{children:"draft"})," and is subject to change at any time."]})}),"\n",(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"rsrchatchannel-membership",children:"rsr.chat/channel-membership"})}),"\n",(0,s.jsx)(n.p,{children:"This extension separates a channel's persistent membership list from its transient list\nof currently connected and joined users. A user may be a recognised member of a channel\nwithout being present in an active IRC session, and may rejoin a channel to which they\nhold membership without requiring an invitation or operator action. Membership entries\ncarry roles, metadata, and join timestamps that survive disconnection. The extension\nintegrates with IRCv3 account-based identity, channel history, and the access control\nand organisational extensions in this suite."}),"\n",(0,s.jsx)(n.h2,{id:"motivation",children:"Motivation"}),"\n",(0,s.jsx)(n.p,{children:"Standard IRC channel membership is entirely session-scoped: the moment a user disconnects\nor issues PART, all record of their association with a channel is lost. Operators must\nre-invite returning users, ban lists are the only persistent per-user state, and there is\nno way to distinguish a long-standing trusted member from an anonymous passer-by. This\nextension provides a first-class persistent membership concept that co-exists cleanly\nwith standard IRC session mechanics and degrades gracefully for clients and servers that\ndo not support it."}),"\n",(0,s.jsx)(n.h2,{id:"capability",children:"Capability"}),"\n",(0,s.jsxs)(n.p,{children:["This extension is advertised as the ",(0,s.jsx)(n.code,{children:"rsr.chat/channel-membership"})," capability during CAP\nnegotiation:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"CAP * LS :rsr.chat/channel-membership\n"})}),"\n",(0,s.jsx)(n.p,{children:"No capability value is used. Limits and feature flags are communicated via ISUPPORT (see\nbelow)."}),"\n",(0,s.jsx)(n.h2,{id:"isupport-tokens",children:"ISUPPORT Tokens"}),"\n",(0,s.jsxs)(n.p,{children:["Servers MUST advertise the following tokens in ",(0,s.jsx)(n.code,{children:"RPL_ISUPPORT"})," (005) when this capability\nis active:"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"MEMBERMAX=<n>"})," \u2014 the maximum number of persistent members a single channel may hold.\nA value of ",(0,s.jsx)(n.code,{children:"0"})," indicates no server-imposed limit."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"MEMBERROLES=<r1>,<r2>,..."})," \u2014 a comma-separated ordered list of role names supported\nby this server, from highest to lowest precedence. Servers MUST include at least\n",(0,s.jsx)(n.code,{children:"owner,admin,op,voice,member"})," in this list. Servers MAY define additional roles between\nthese. Role names are case-insensitive ASCII."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"MEMBERPERSIST=1"})," \u2014 present if the server retains membership data across restarts.\nAbsent if membership is in-memory only and may be lost on restart."]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"Example:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:":server 005 nick MEMBERMAX=500 MEMBERROLES=owner,admin,op,voice,member MEMBERPERSIST=1 :are supported by this server\n"})}),"\n",(0,s.jsxs)(n.p,{children:["If any of these values change after a configuration reload, a fresh ",(0,s.jsx)(n.code,{children:"RPL_ISUPPORT"})," MUST be\nsent to all connected clients."]}),"\n",(0,s.jsx)(n.h2,{id:"terminology",children:"Terminology"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Persistent member"}),": an account that has been added to a channel's membership list.\nMembership survives session end."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Active member"}),": a persistent member who is also currently connected and has an active\nJOIN state in the channel."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Transient member"}),": a user currently joined to a channel who is not a persistent\nmember. Standard IRC session mechanics apply to transient members without modification."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Role"}),": a named rank assigned to a persistent member, drawn from the server's\n",(0,s.jsx)(n.code,{children:"MEMBERROLES"})," list."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Account"}),": a registered services identity, as established by IRCv3 ",(0,s.jsx)(n.code,{children:"account-tag"})," or\nequivalent mechanisms. Persistent membership is always bound to an account, never to a\nnick or hostmask alone."]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"account-requirement",children:"Account Requirement"}),"\n",(0,s.jsx)(n.p,{children:"Persistent membership is identity-based and requires that the target user hold a\nrecognised account. Servers MUST refuse CHMEMBER ADD for a nick that is not currently\nidentified to an account, returning ERR_NOTREGISTERED. Membership records store the\naccount name, not the nick. When an account holder connects and joins a channel, the\nserver resolves their current nick to their account for membership lookup."}),"\n",(0,s.jsx)(n.p,{children:"Servers that do not support account services MUST NOT advertise this capability."}),"\n",(0,s.jsx)(n.h2,{id:"roles",children:"Roles"}),"\n",(0,s.jsxs)(n.p,{children:["Every persistent member is assigned exactly one role at the time they are added. The\ndefault role for CHMEMBER ADD, if no role is specified, is ",(0,s.jsx)(n.code,{children:"member"}),". Roles map to\nstandard IRC channel privileges as follows:"]}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"Role"}),(0,s.jsx)(n.th,{children:"IRC mode equivalent"}),(0,s.jsx)(n.th,{children:"Effective privilege"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"owner"})}),(0,s.jsxs)(n.td,{children:[(0,s.jsx)(n.code,{children:"+q"})," (where supported), else ",(0,s.jsx)(n.code,{children:"+o"})]}),(0,s.jsx)(n.td,{children:"Full channel control"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"admin"})}),(0,s.jsxs)(n.td,{children:[(0,s.jsx)(n.code,{children:"+a"})," (where supported), else ",(0,s.jsx)(n.code,{children:"+o"})]}),(0,s.jsx)(n.td,{children:"Administrative privileges"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"op"})}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"+o"})}),(0,s.jsx)(n.td,{children:"Standard channel operator"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"voice"})}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"+v"})}),(0,s.jsx)(n.td,{children:"Ability to speak in moderated channels"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"member"})}),(0,s.jsx)(n.td,{children:"(none)"}),(0,s.jsx)(n.td,{children:"Recognised member, no extra privilege"})]})]})]}),"\n",(0,s.jsx)(n.p,{children:"When a persistent member joins a channel as an active member, the server MUST\nautomatically apply the IRC mode corresponding to their role. Servers MUST do this\nwithout requiring operator intervention and MUST complete the mode application before\nsending the JOIN confirmation to the channel."}),"\n",(0,s.jsxs)(n.p,{children:["If ",(0,s.jsx)(n.code,{children:"multi-prefix"})," is negotiated, the automatically applied mode MUST appear in NAMES and\nWHO responses as normal."]}),"\n",(0,s.jsx)(n.h2,{id:"commands",children:"Commands"}),"\n",(0,s.jsx)(n.h3,{id:"chmember-add",children:"CHMEMBER ADD"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"CHMEMBER <channel> ADD <nick> [<role>]\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Adds the account currently identified by ",(0,s.jsx)(n.code,{children:"<nick>"})," to the channel's persistent membership\nlist, optionally at the specified role. If ",(0,s.jsx)(n.code,{children:"<role>"})," is omitted, ",(0,s.jsx)(n.code,{children:"member"})," is assumed."]}),"\n",(0,s.jsxs)(n.p,{children:["The requesting client MUST be an active member with a role of ",(0,s.jsx)(n.code,{children:"op"})," or higher, or a server\noperator, unless overridden by ",(0,s.jsx)(n.code,{children:"rsr.chat/rbac"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:["On success the server MUST broadcast a ",(0,s.jsx)(n.code,{children:"CHMEMBER ADD"})," message to all active channel\nmembers that have negotiated this capability:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:":adder!user@host CHMEMBER #channel ADD <accountname> <role>\n"})}),"\n",(0,s.jsx)(n.h3,{id:"chmember-remove",children:"CHMEMBER REMOVE"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"CHMEMBER <channel> REMOVE <nick> [:<reason>]\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Removes the persistent membership of the account identified by ",(0,s.jsx)(n.code,{children:"<nick>"}),". If the target is\ncurrently active in the channel, they are not forced to part; their session continues as a\ntransient member until they disconnect or part."]}),"\n",(0,s.jsxs)(n.p,{children:["On success the server MUST broadcast a ",(0,s.jsx)(n.code,{children:"CHMEMBER REMOVE"})," message to all active channel\nmembers that have negotiated this capability:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:":remover!user@host CHMEMBER #channel REMOVE <accountname> [:<reason>]\n"})}),"\n",(0,s.jsx)(n.h3,{id:"chmember-setrole",children:"CHMEMBER SETROLE"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"CHMEMBER <channel> SETROLE <nick> <role>\n"})}),"\n",(0,s.jsx)(n.p,{children:"Changes the role of an existing persistent member. The requesting client's role MUST be\nhigher in precedence than the target's current role and higher than or equal to the\nrequested new role. A client may not promote another member to a role equal to or higher\nthan their own."}),"\n",(0,s.jsxs)(n.p,{children:["On success the server MUST broadcast a ",(0,s.jsx)(n.code,{children:"CHMEMBER SETROLE"})," message to all active channel\nmembers that have negotiated this capability:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:":setter!user@host CHMEMBER #channel SETROLE <accountname> <role>\n"})}),"\n",(0,s.jsx)(n.p,{children:"If the target is currently active in the channel, the server MUST update their IRC\nchannel mode to reflect the new role immediately."}),"\n",(0,s.jsx)(n.h3,{id:"chmember-list",children:"CHMEMBER LIST"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"CHMEMBER <channel> LIST\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Requests the full persistent membership list for the channel. The server responds with\none or more RPL_MEMBERENTRY numerics followed by RPL_MEMBEREND. If IRCv3 ",(0,s.jsx)(n.code,{children:"batch"})," is\nnegotiated the entire list MUST be wrapped in a ",(0,s.jsx)(n.code,{children:"rsr.chat/memberlist"})," batch."]}),"\n",(0,s.jsx)(n.h3,{id:"chmember-invite",children:"CHMEMBER INVITE"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"CHMEMBER <channel> INVITE <nick>\n"})}),"\n",(0,s.jsx)(n.p,{children:"Grants a one-time session join permission to the specified nick for a channel that is\ninvite-only (+i), without adding them to the persistent membership list. This is\nequivalent to a standard INVITE but issued via the membership command surface. If the\ntarget is a persistent member, this command has no effect and the server MUST reply with\nERR_ALREADYMEMBER."}),"\n",(0,s.jsx)(n.h2,{id:"server-numerics",children:"Server Numerics"}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"Symbolic name"}),(0,s.jsx)(n.th,{children:"Description"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"RPL_MEMBERENTRY"})}),(0,s.jsx)(n.td,{children:"A single persistent membership entry"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"RPL_MEMBEREND"})}),(0,s.jsx)(n.td,{children:"Marks the end of a CHMEMBER LIST response"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"ERR_NOTREGISTERED"})}),(0,s.jsx)(n.td,{children:"Target nick is not identified to an account"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"ERR_NOTAMEMBER"})}),(0,s.jsx)(n.td,{children:"Target account is not a persistent member of this channel"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"ERR_ALREADYMEMBER"})}),(0,s.jsx)(n.td,{children:"Target account is already a persistent member of this channel"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"ERR_MEMBERROLE"})}),(0,s.jsx)(n.td,{children:"The requesting client's role is insufficient for this operation"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"ERR_MEMBERFULL"})}),(0,s.jsx)(n.td,{children:"The channel has reached the MEMBERMAX limit"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"ERR_MEMBERROLEINVAL"})}),(0,s.jsx)(n.td,{children:"The specified role is not in the server's MEMBERROLES list"})]})]})]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"RPL_MEMBERENTRY"})," has the following format:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:":server RPL_MEMBERENTRY <nick> <channel> <accountname> <role> <joined-timestamp> [flags]\n"})}),"\n",(0,s.jsx)(n.p,{children:"Where:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"accountname"})," is the account name of the member."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"role"})," is their current role."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"joined-timestamp"})," is an ISO 8601 UTC timestamp recording when they were first added to\nthe membership list."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"flags"})," is an optional space-separated list of server-supplied annotations. Currently\ndefined flags:","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"active"})," \u2014 the member is currently connected and joined."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"away"})," \u2014 the member is currently active but marked away (see IRCv3 Integration)."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"offline"})," \u2014 the member holds membership but is not currently connected."]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"RPL_MEMBEREND"})," has the following format:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:":server RPL_MEMBEREND <nick> <channel> :End of channel membership list\n"})}),"\n",(0,s.jsx)(n.h2,{id:"interaction-with-standard-join-and-part",children:"Interaction with Standard JOIN and PART"}),"\n",(0,s.jsx)(n.h3,{id:"join-by-a-persistent-member",children:"JOIN by a persistent member"}),"\n",(0,s.jsx)(n.p,{children:"When a persistent member joins a channel the server MUST:"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsx)(n.li,{children:"Process the JOIN normally, broadcasting it to all channel members."}),"\n",(0,s.jsx)(n.li,{children:"Automatically apply the mode corresponding to their role before or atomically with the\nJOIN broadcast, such that receiving clients observe the mode in NAMES immediately."}),"\n",(0,s.jsxs)(n.li,{children:["Broadcast a ",(0,s.jsx)(n.code,{children:"CHMEMBER ACTIVE"})," event to all active members that have negotiated this\ncapability, indicating the member has transitioned from offline to active:"]}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:":server CHMEMBER #channel ACTIVE <accountname>\n"})}),"\n",(0,s.jsx)(n.h3,{id:"part-or-quit-by-a-persistent-member",children:"PART or QUIT by a persistent member"}),"\n",(0,s.jsxs)(n.p,{children:["When a persistent member parts or quits, their persistent membership record is NOT\nremoved. The server MUST broadcast a standard PART or QUIT as normal, and MUST broadcast\na ",(0,s.jsx)(n.code,{children:"CHMEMBER INACTIVE"})," event to all remaining active members that have negotiated this\ncapability:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"    :server CHMEMBER #channel INACTIVE <accountname>\n"})}),"\n",(0,s.jsx)(n.p,{children:"The member's role is preserved for their next session."}),"\n",(0,s.jsx)(n.h3,{id:"kick-of-a-persistent-member",children:"KICK of a persistent member"}),"\n",(0,s.jsx)(n.p,{children:"A KICK removes the target from the active session but MUST NOT remove their persistent\nmembership by default. Servers MUST accept an extended KICK syntax to simultaneously\nremove persistent membership:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"KICK <channel> <nick> [--remove-membership] [:<reason>]\n"})}),"\n",(0,s.jsxs)(n.p,{children:["If ",(0,s.jsx)(n.code,{children:"--remove-membership"})," is present and the kicker's role is sufficient to call\nCHMEMBER REMOVE, the persistent membership is also removed. Servers that do not support\nthe flag MUST treat a KICK as session-only."]}),"\n",(0,s.jsx)(n.h3,{id:"channel-destruction",children:"Channel destruction"}),"\n",(0,s.jsx)(n.p,{children:"If a channel becomes empty of active members, the server MUST NOT destroy the channel if\nit has a non-empty persistent membership list. The channel persists in an idle state\nuntil a persistent member returns. Servers MAY destroy channels with empty persistent\nmembership lists on the normal empty-channel timeout."}),"\n",(0,s.jsx)(n.h2,{id:"names-and-who-integration",children:"NAMES and WHO Integration"}),"\n",(0,s.jsx)(n.p,{children:"When responding to NAMES (353) or WHO for a channel, servers MUST include only currently\nactive members in the reply, consistent with standard IRC behaviour. Persistent but\ncurrently offline members MUST NOT appear in NAMES or WHO."}),"\n",(0,s.jsx)(n.p,{children:"Clients that wish to see the full membership list including offline members MUST use\nCHMEMBER LIST."}),"\n",(0,s.jsxs)(n.p,{children:["If ",(0,s.jsx)(n.code,{children:"userhost-in-names"})," is negotiated, active persistent members appear with their current\nhostmask as normal."]}),"\n",(0,s.jsxs)(n.p,{children:["If ",(0,s.jsx)(n.code,{children:"multi-prefix"})," is negotiated, the automatically applied role mode prefix appears in\nNAMES as normal."]}),"\n",(0,s.jsx)(n.h2,{id:"ircv3-integration",children:"IRCv3 Integration"}),"\n",(0,s.jsx)(n.h3,{id:"account-tag",children:"account-tag"}),"\n",(0,s.jsxs)(n.p,{children:["Persistent membership is bound to account names resolved via the ",(0,s.jsx)(n.code,{children:"account-tag"})," mechanism.\nWhen a client with a recognised account joins a channel the server resolves the account\nname to check for existing membership before processing the JOIN. Servers MUST NOT add\npersistent members based on nick or hostmask alone."]}),"\n",(0,s.jsx)(n.h3,{id:"away-notify",children:"away-notify"}),"\n",(0,s.jsxs)(n.p,{children:["When ",(0,s.jsx)(n.code,{children:"away-notify"})," is negotiated, transitions between active and away state for persistent\nmembers who are currently offline MUST NOT generate spurious AWAY notifications. Only\nactive members (currently joined) generate ",(0,s.jsx)(n.code,{children:"away-notify"})," events as normal."]}),"\n",(0,s.jsxs)(n.p,{children:["When a persistent member becomes active (joins) they receive the current away status of\nall other active members in the join burst if ",(0,s.jsx)(n.code,{children:"away-notify"})," is negotiated, consistent with\nexisting ",(0,s.jsx)(n.code,{children:"away-notify"})," semantics."]}),"\n",(0,s.jsx)(n.h3,{id:"batch",children:"batch"}),"\n",(0,s.jsxs)(n.p,{children:["CHMEMBER LIST responses MUST be wrapped in a ",(0,s.jsx)(n.code,{children:"rsr.chat/memberlist"})," batch when the\nrequesting client has negotiated IRCv3 ",(0,s.jsx)(n.code,{children:"batch"}),". Servers MUST NOT send RPL_MEMBERENTRY\noutside of a batch when ",(0,s.jsx)(n.code,{children:"batch"})," is negotiated."]}),"\n",(0,s.jsx)(n.h3,{id:"chathistory",children:"chathistory"}),"\n",(0,s.jsxs)(n.p,{children:["Persistent members MUST be permitted to request message history for channels in which\nthey hold membership, even when they are not currently joined. A persistent member\nwith role ",(0,s.jsx)(n.code,{children:"member"})," or above MAY issue a CHATHISTORY command targeting a channel they\nbelong to while offline. The server MUST honour this request and return history up to the\nchannel's retention window."]}),"\n",(0,s.jsx)(n.p,{children:"Transient members (users who were previously joined but hold no persistent membership)\nMUST NOT receive history for periods when they were not actively joined, consistent with\nstandard chathistory access rules."}),"\n",(0,s.jsx)(n.h3,{id:"extended-join",children:"extended-join"}),"\n",(0,s.jsxs)(n.p,{children:["When ",(0,s.jsx)(n.code,{children:"extended-join"})," is negotiated, the JOIN broadcast for a persistent member MUST\ninclude their account name in the extended format. Receiving clients can thereby\ncorrelate the joining user with their persistent membership entry."]}),"\n",(0,s.jsx)(n.h3,{id:"invite-notify",children:"invite-notify"}),"\n",(0,s.jsxs)(n.p,{children:["When ",(0,s.jsx)(n.code,{children:"invite-notify"})," is negotiated, CHMEMBER INVITE events are broadcast to all active\nchannel members that have negotiated both ",(0,s.jsx)(n.code,{children:"invite-notify"})," and ",(0,s.jsx)(n.code,{children:"rsr.chat/channel-membership"}),"\nusing the standard INVITE notification format, consistent with ",(0,s.jsx)(n.code,{children:"invite-notify"})," semantics."]}),"\n",(0,s.jsx)(n.h3,{id:"monitor",children:"monitor"}),"\n",(0,s.jsx)(n.p,{children:"The MONITOR list of persistent members is independent of channel membership. If a\npersistent member for whom another client has a MONITOR entry connects, the standard\nRPL_MONONLINE notification is sent as normal. No MONITOR events are generated solely\nbecause of membership list changes."}),"\n",(0,s.jsx)(n.h2,{id:"reserved-metadata-keys",children:"Reserved Metadata Keys"}),"\n",(0,s.jsxs)(n.p,{children:["When both ",(0,s.jsx)(n.code,{children:"rsr.chat/channel-metadata"})," and ",(0,s.jsx)(n.code,{children:"rsr.chat/channel-membership"})," are negotiated,\nthe following keys exist implicitly on every channel and cannot be deleted:"]}),"\n",(0,s.jsx)(n.h3,{id:"membership-count",children:(0,s.jsx)(n.code,{children:"membership-count"})}),"\n",(0,s.jsxs)(n.p,{children:["Type: ",(0,s.jsx)(n.code,{children:"uint"}),". The current number of persistent members. Updated by the server on each\nCHMEMBER ADD or REMOVE. Read-only; attempts to set via CHANMETA SET MUST result in\nERR_CHANMETAREADONLY."]}),"\n",(0,s.jsx)(n.h3,{id:"membership-open",children:(0,s.jsx)(n.code,{children:"membership-open"})}),"\n",(0,s.jsxs)(n.p,{children:["Type: ",(0,s.jsx)(n.code,{children:"bool"}),". When ",(0,s.jsx)(n.code,{children:"true"}),", any authenticated user may add themselves to the membership\nlist via ",(0,s.jsx)(n.code,{children:"CHMEMBER <channel> ADD <own-nick>"})," without requiring operator approval. When\n",(0,s.jsx)(n.code,{children:"false"}),", only users with role ",(0,s.jsx)(n.code,{children:"op"})," or higher may add new members. Default: ",(0,s.jsx)(n.code,{children:"false"}),"."]}),"\n",(0,s.jsx)(n.h2,{id:"guild-integration",children:"Guild Integration"}),"\n",(0,s.jsxs)(n.p,{children:["When ",(0,s.jsx)(n.code,{children:"rsr.chat/guild"})," is negotiated, the guild operator role implicitly supersedes\n",(0,s.jsx)(n.code,{children:"owner"})," for all channels within the guild. Guild operators MAY add, remove, or change the\nrole of any persistent member in any guild channel without holding a channel-level role\nthemselves."]}),"\n",(0,s.jsxs)(n.p,{children:["Persistent membership records MUST be exported and visible within guild-scoped CHMEMBER\nLIST queries if the guild specification defines a guild-wide member listing mechanism.\nThe specific syntax for guild-wide membership queries is defined by ",(0,s.jsx)(n.code,{children:"rsr.chat/guild"}),"."]}),"\n",(0,s.jsx)(n.h2,{id:"category-integration",children:"Category Integration"}),"\n",(0,s.jsxs)(n.p,{children:["When ",(0,s.jsx)(n.code,{children:"rsr.chat/channel-categories"})," is negotiated, CHMEMBER ADD MAY be performed at a\ncategory scope, adding a user as a persistent member of all channels that currently exist\nwithin that category:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"CHMEMBER #engineering/ ADD <nick> <role>\n"})}),"\n",(0,s.jsxs)(n.p,{children:["This is a convenience operation equivalent to issuing CHMEMBER ADD individually for each\nmatching channel. The server MUST apply the operation atomically and MUST reply with\na success or error numeric for each channel individually in a ",(0,s.jsx)(n.code,{children:"rsr.chat/memberlist"})," batch.\nChannels created within the category after a scoped ADD are not automatically affected;\nthe scope applies only at the time of the command."]}),"\n",(0,s.jsx)(n.h2,{id:"rbac-integration",children:"RBAC Integration"}),"\n",(0,s.jsxs)(n.p,{children:["When ",(0,s.jsx)(n.code,{children:"rsr.chat/rbac"})," is negotiated, the following permission identifiers are defined by\nthis extension:"]}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"Permission identifier"}),(0,s.jsx)(n.th,{children:"Description"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"membership.list"})}),(0,s.jsx)(n.td,{children:"View the persistent membership list"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"membership.add"})}),(0,s.jsx)(n.td,{children:"Add a new persistent member"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"membership.remove"})}),(0,s.jsx)(n.td,{children:"Remove a persistent member"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"membership.setrole"})}),(0,s.jsx)(n.td,{children:"Change a member's role"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"membership.invite"})}),(0,s.jsx)(n.td,{children:"Issue a one-time session invite"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"membership.self.add"})}),(0,s.jsx)(n.td,{children:"Add oneself to a channel's membership list"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"membership.self.remove"})}),(0,s.jsx)(n.td,{children:"Remove oneself from a channel's membership list"})]})]})]}),"\n",(0,s.jsxs)(n.p,{children:["RBAC rules for these permissions MAY be scoped to a channel category or guild prefix\nusing the scope syntax defined by ",(0,s.jsx)(n.code,{children:"rsr.chat/channel-categories"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:["Furthermore, the ",(0,s.jsx)(n.code,{children:"ISUPPORT"})," parameter ",(0,s.jsx)(n.code,{children:"MEMBERROLES"})," MUST contain the value ",(0,s.jsx)(n.code,{children:"rsr.chat/rbac"}),",\nwhich MUST be understood by clients implementing both extensions."]}),"\n",(0,s.jsx)(n.h2,{id:"advanced-moderation-integration",children:"Advanced Moderation Integration"}),"\n",(0,s.jsxs)(n.p,{children:["When ",(0,s.jsx)(n.code,{children:"rsr.chat/advanced-moderation"})," is negotiated, the following predicates are defined\nfor use in moderation rule conditions (normative syntax defined by that specification):"]}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"Predicate"}),(0,s.jsx)(n.th,{children:"Matches when"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"membership:is-member"})}),(0,s.jsx)(n.td,{children:"The acting user is a persistent member"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"membership:role=<role>"})}),(0,s.jsx)(n.td,{children:"The acting user holds exactly the specified role"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"membership:role>=<role>"})}),(0,s.jsx)(n.td,{children:"The acting user's role is equal to or higher than specified"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"membership:is-active"})}),(0,s.jsx)(n.td,{children:"The user is a persistent member and currently joined"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"membership:is-offline"})}),(0,s.jsx)(n.td,{children:"The user holds membership but is not currently joined"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"membership:member-count>=<n>"})}),(0,s.jsx)(n.td,{children:"The channel has at least n persistent members"})]})]})]}),"\n",(0,s.jsx)(n.p,{children:"These predicates may be used to restrict posting, joining, or other actions to persistent\nmembers only, to gate on role level, or to allow offline members to perform out-of-session\nactions such as chathistory requests."}),"\n",(0,s.jsx)(n.h2,{id:"interaction-with-non-negotiating-clients",children:"Interaction with Non-Negotiating Clients"}),"\n",(0,s.jsxs)(n.p,{children:["Clients that have not negotiated ",(0,s.jsx)(n.code,{children:"rsr.chat/channel-membership"})," observe no changes to\nstandard IRC mechanics. NAMES and WHO responses contain only active members as normal.\nAutomatic mode application when a persistent member joins is indistinguishable from a\nstandard operator applying modes manually. CHMEMBER commands sent by non-negotiating\nclients MUST be rejected with ERR_UNKNOWNCOMMAND."]}),"\n",(0,s.jsx)(n.p,{children:"Non-negotiating clients that are persistent members receive the same automatic mode\napplication on join as negotiating clients, since that is expressed through standard IRC\nmode messages they already understand."}),"\n",(0,s.jsx)(n.h2,{id:"examples",children:"Examples"}),"\n",(0,s.jsx)(n.h3,{id:"adding-a-persistent-member",children:"Adding a persistent member"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"C: CHMEMBER #engineering/general ADD bob op\nS: :alice!alice@host CHMEMBER #engineering/general ADD bob op\n    (broadcast to all active members that negotiated the capability)\n"})}),"\n",(0,s.jsx)(n.h3,{id:"persistent-member-joins-and-receives-automatic-mode",children:"Persistent member joins and receives automatic mode"}),"\n",(0,s.jsx)(n.p,{children:"(bob connects and joins #engineering/general, where he is a persistent member with role op)"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"S: :bob!bob@host JOIN #engineering/general\nS: :server MODE #engineering/general +o bob\nS: :server CHMEMBER #engineering/general ACTIVE bob\n    (broadcast to active members that negotiated the capability)\n"})}),"\n",(0,s.jsx)(n.h3,{id:"chmember-list-with-batch",children:"CHMEMBER LIST with batch"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"C: CHMEMBER #engineering/general LIST\nS: :server BATCH +ml rsr.chat/memberlist #engineering/general\nS: @batch=ml :server RPL_MEMBERENTRY alice #engineering/general alice_acct owner 2023-11-01T09:00:00.000Z active\nS: @batch=ml :server RPL_MEMBERENTRY alice #engineering/general bob_acct op 2023-11-03T14:22:10.000Z active away\nS: @batch=ml :server RPL_MEMBERENTRY alice #engineering/general carol_acct member 2024-01-15T08:45:00.000Z offline\nS: :server BATCH -ml\nS: :server RPL_MEMBEREND alice #engineering/general :End of channel membership list\n"})}),"\n",(0,s.jsx)(n.h3,{id:"persistent-member-parts-membership-retained",children:"Persistent member parts; membership retained"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"C: PART #engineering/general\nS: :bob!bob@host PART #engineering/general\nS: :server CHMEMBER #engineering/general INACTIVE bob\n    (broadcast to remaining active members that negotiated the capability)\n(bob's membership record and role are preserved)\n"})}),"\n",(0,s.jsx)(n.h3,{id:"kick-without-membership-removal",children:"Kick without membership removal"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"C: KICK #engineering/general bob :Please rejoin when available\nS: :alice!alice@host KICK #engineering/general bob :Please rejoin when available\n(bob is removed from the active session; persistent membership is unaffected)\n"})}),"\n",(0,s.jsx)(n.h3,{id:"kick-with-membership-removal",children:"Kick with membership removal"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"C: KICK #engineering/general bob --remove-membership :Conduct violation\nS: :alice!alice@host KICK #engineering/general bob :Conduct violation\nS: :alice!alice@host CHMEMBER #engineering/general REMOVE bob :Conduct violation\n    (broadcast to active members that negotiated the capability)\n"})}),"\n",(0,s.jsx)(n.h3,{id:"role-change-while-member-is-active",children:"Role change while member is active"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"C: CHMEMBER #engineering/general SETROLE bob voice\nS: :alice!alice@host CHMEMBER #engineering/general SETROLE bob voice\nS: :server MODE #engineering/general -o+v bob\n    (mode updated immediately since bob is currently active)\n"})}),"\n",(0,s.jsx)(n.h3,{id:"offline-member-requesting-history-via-chathistory",children:"Offline member requesting history via chathistory"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"(carol is a persistent member but is not currently joined)\nC: CHATHISTORY LATEST #engineering/general * 50\nS: (history returned for #engineering/general up to retention window)\n"})}),"\n",(0,s.jsx)(n.h3,{id:"insufficient-role-error",children:"Insufficient role error"}),"\n",(0,s.jsx)(n.p,{children:"(bob has role voice and attempts to add a new member)"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"C: CHMEMBER #engineering/general ADD carol member\nS: :server ERR_MEMBERROLE bob #engineering/general :Insufficient role to add members\n"})}),"\n",(0,s.jsx)(n.h3,{id:"category-scoped-add",children:"Category-scoped ADD"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"C: CHMEMBER #engineering/ ADD carol member\nS: :server BATCH +cm rsr.chat/memberlist #engineering/\nS: @batch=cm :server RPL_MEMBERENTRY alice #engineering/general carol_acct member 2024-03-15T10:00:00.000Z offline\nS: @batch=cm :server RPL_MEMBERENTRY alice #engineering/deploys carol_acct member 2024-03-15T10:00:00.000Z offline\nS: :server BATCH -cm\n"})})]})}function h(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(l,{...e})}):l(e)}},8453(e,n,i){i.d(n,{R:()=>a,x:()=>c});var r=i(6540);const s={},t=r.createContext(s);function a(e){const n=r.useContext(t);return r.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function c(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:a(e.components),r.createElement(t.Provider,{value:n},e.children)}}}]);